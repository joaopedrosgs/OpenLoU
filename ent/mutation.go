// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"openlou/ent/city"
	"openlou/ent/construction"
	"openlou/ent/predicate"
	"openlou/ent/queue"
	"openlou/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCity         = "City"
	TypeConstruction = "Construction"
	TypeQueue        = "Queue"
	TypeUser         = "User"
)

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	x                     *int
	addx                  *int
	y                     *int
	addy                  *int
	name                  *string
	points                *int
	addpoints             *int
	wood_production       *int
	addwood_production    *int
	stone_production      *int
	addstone_production   *int
	iron_production       *int
	addiron_production    *int
	food_production       *int
	addfood_production    *int
	wood_stored           *int
	addwood_stored        *int
	stone_stored          *int
	addstone_stored       *int
	iron_stored           *int
	addiron_stored        *int
	food_stored           *int
	addfood_stored        *int
	wood_limit            *int
	addwood_limit         *int
	stone_limit           *int
	addstone_limit        *int
	iron_limit            *int
	addiron_limit         *int
	food_limit            *int
	addfood_limit         *int
	queue_time            *time.Time
	construction_speed    *int
	addconstruction_speed *int
	clearedFields         map[string]struct{}
	owner                 *int
	clearedowner          bool
	constructions         map[int]struct{}
	removedconstructions  map[int]struct{}
	clearedconstructions  bool
	queue                 map[int]struct{}
	removedqueue          map[int]struct{}
	clearedqueue          bool
	done                  bool
	oldValue              func(context.Context) (*City, error)
	predicates            []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetX sets the "x" field.
func (m *CityMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *CityMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *CityMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *CityMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *CityMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *CityMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *CityMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *CityMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *CityMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *CityMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetPoints sets the "points" field.
func (m *CityMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *CityMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *CityMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *CityMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *CityMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetWoodProduction sets the "wood_production" field.
func (m *CityMutation) SetWoodProduction(i int) {
	m.wood_production = &i
	m.addwood_production = nil
}

// WoodProduction returns the value of the "wood_production" field in the mutation.
func (m *CityMutation) WoodProduction() (r int, exists bool) {
	v := m.wood_production
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodProduction returns the old "wood_production" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldWoodProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWoodProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWoodProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodProduction: %w", err)
	}
	return oldValue.WoodProduction, nil
}

// AddWoodProduction adds i to the "wood_production" field.
func (m *CityMutation) AddWoodProduction(i int) {
	if m.addwood_production != nil {
		*m.addwood_production += i
	} else {
		m.addwood_production = &i
	}
}

// AddedWoodProduction returns the value that was added to the "wood_production" field in this mutation.
func (m *CityMutation) AddedWoodProduction() (r int, exists bool) {
	v := m.addwood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodProduction resets all changes to the "wood_production" field.
func (m *CityMutation) ResetWoodProduction() {
	m.wood_production = nil
	m.addwood_production = nil
}

// SetStoneProduction sets the "stone_production" field.
func (m *CityMutation) SetStoneProduction(i int) {
	m.stone_production = &i
	m.addstone_production = nil
}

// StoneProduction returns the value of the "stone_production" field in the mutation.
func (m *CityMutation) StoneProduction() (r int, exists bool) {
	v := m.stone_production
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneProduction returns the old "stone_production" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldStoneProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoneProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoneProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneProduction: %w", err)
	}
	return oldValue.StoneProduction, nil
}

// AddStoneProduction adds i to the "stone_production" field.
func (m *CityMutation) AddStoneProduction(i int) {
	if m.addstone_production != nil {
		*m.addstone_production += i
	} else {
		m.addstone_production = &i
	}
}

// AddedStoneProduction returns the value that was added to the "stone_production" field in this mutation.
func (m *CityMutation) AddedStoneProduction() (r int, exists bool) {
	v := m.addstone_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneProduction resets all changes to the "stone_production" field.
func (m *CityMutation) ResetStoneProduction() {
	m.stone_production = nil
	m.addstone_production = nil
}

// SetIronProduction sets the "iron_production" field.
func (m *CityMutation) SetIronProduction(i int) {
	m.iron_production = &i
	m.addiron_production = nil
}

// IronProduction returns the value of the "iron_production" field in the mutation.
func (m *CityMutation) IronProduction() (r int, exists bool) {
	v := m.iron_production
	if v == nil {
		return
	}
	return *v, true
}

// OldIronProduction returns the old "iron_production" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldIronProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIronProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIronProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronProduction: %w", err)
	}
	return oldValue.IronProduction, nil
}

// AddIronProduction adds i to the "iron_production" field.
func (m *CityMutation) AddIronProduction(i int) {
	if m.addiron_production != nil {
		*m.addiron_production += i
	} else {
		m.addiron_production = &i
	}
}

// AddedIronProduction returns the value that was added to the "iron_production" field in this mutation.
func (m *CityMutation) AddedIronProduction() (r int, exists bool) {
	v := m.addiron_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronProduction resets all changes to the "iron_production" field.
func (m *CityMutation) ResetIronProduction() {
	m.iron_production = nil
	m.addiron_production = nil
}

// SetFoodProduction sets the "food_production" field.
func (m *CityMutation) SetFoodProduction(i int) {
	m.food_production = &i
	m.addfood_production = nil
}

// FoodProduction returns the value of the "food_production" field in the mutation.
func (m *CityMutation) FoodProduction() (r int, exists bool) {
	v := m.food_production
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodProduction returns the old "food_production" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldFoodProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoodProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoodProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodProduction: %w", err)
	}
	return oldValue.FoodProduction, nil
}

// AddFoodProduction adds i to the "food_production" field.
func (m *CityMutation) AddFoodProduction(i int) {
	if m.addfood_production != nil {
		*m.addfood_production += i
	} else {
		m.addfood_production = &i
	}
}

// AddedFoodProduction returns the value that was added to the "food_production" field in this mutation.
func (m *CityMutation) AddedFoodProduction() (r int, exists bool) {
	v := m.addfood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodProduction resets all changes to the "food_production" field.
func (m *CityMutation) ResetFoodProduction() {
	m.food_production = nil
	m.addfood_production = nil
}

// SetWoodStored sets the "wood_stored" field.
func (m *CityMutation) SetWoodStored(i int) {
	m.wood_stored = &i
	m.addwood_stored = nil
}

// WoodStored returns the value of the "wood_stored" field in the mutation.
func (m *CityMutation) WoodStored() (r int, exists bool) {
	v := m.wood_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodStored returns the old "wood_stored" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldWoodStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWoodStored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWoodStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodStored: %w", err)
	}
	return oldValue.WoodStored, nil
}

// AddWoodStored adds i to the "wood_stored" field.
func (m *CityMutation) AddWoodStored(i int) {
	if m.addwood_stored != nil {
		*m.addwood_stored += i
	} else {
		m.addwood_stored = &i
	}
}

// AddedWoodStored returns the value that was added to the "wood_stored" field in this mutation.
func (m *CityMutation) AddedWoodStored() (r int, exists bool) {
	v := m.addwood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodStored resets all changes to the "wood_stored" field.
func (m *CityMutation) ResetWoodStored() {
	m.wood_stored = nil
	m.addwood_stored = nil
}

// SetStoneStored sets the "stone_stored" field.
func (m *CityMutation) SetStoneStored(i int) {
	m.stone_stored = &i
	m.addstone_stored = nil
}

// StoneStored returns the value of the "stone_stored" field in the mutation.
func (m *CityMutation) StoneStored() (r int, exists bool) {
	v := m.stone_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneStored returns the old "stone_stored" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldStoneStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoneStored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoneStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneStored: %w", err)
	}
	return oldValue.StoneStored, nil
}

// AddStoneStored adds i to the "stone_stored" field.
func (m *CityMutation) AddStoneStored(i int) {
	if m.addstone_stored != nil {
		*m.addstone_stored += i
	} else {
		m.addstone_stored = &i
	}
}

// AddedStoneStored returns the value that was added to the "stone_stored" field in this mutation.
func (m *CityMutation) AddedStoneStored() (r int, exists bool) {
	v := m.addstone_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneStored resets all changes to the "stone_stored" field.
func (m *CityMutation) ResetStoneStored() {
	m.stone_stored = nil
	m.addstone_stored = nil
}

// SetIronStored sets the "iron_stored" field.
func (m *CityMutation) SetIronStored(i int) {
	m.iron_stored = &i
	m.addiron_stored = nil
}

// IronStored returns the value of the "iron_stored" field in the mutation.
func (m *CityMutation) IronStored() (r int, exists bool) {
	v := m.iron_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldIronStored returns the old "iron_stored" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldIronStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIronStored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIronStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronStored: %w", err)
	}
	return oldValue.IronStored, nil
}

// AddIronStored adds i to the "iron_stored" field.
func (m *CityMutation) AddIronStored(i int) {
	if m.addiron_stored != nil {
		*m.addiron_stored += i
	} else {
		m.addiron_stored = &i
	}
}

// AddedIronStored returns the value that was added to the "iron_stored" field in this mutation.
func (m *CityMutation) AddedIronStored() (r int, exists bool) {
	v := m.addiron_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronStored resets all changes to the "iron_stored" field.
func (m *CityMutation) ResetIronStored() {
	m.iron_stored = nil
	m.addiron_stored = nil
}

// SetFoodStored sets the "food_stored" field.
func (m *CityMutation) SetFoodStored(i int) {
	m.food_stored = &i
	m.addfood_stored = nil
}

// FoodStored returns the value of the "food_stored" field in the mutation.
func (m *CityMutation) FoodStored() (r int, exists bool) {
	v := m.food_stored
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodStored returns the old "food_stored" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldFoodStored(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoodStored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoodStored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodStored: %w", err)
	}
	return oldValue.FoodStored, nil
}

// AddFoodStored adds i to the "food_stored" field.
func (m *CityMutation) AddFoodStored(i int) {
	if m.addfood_stored != nil {
		*m.addfood_stored += i
	} else {
		m.addfood_stored = &i
	}
}

// AddedFoodStored returns the value that was added to the "food_stored" field in this mutation.
func (m *CityMutation) AddedFoodStored() (r int, exists bool) {
	v := m.addfood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodStored resets all changes to the "food_stored" field.
func (m *CityMutation) ResetFoodStored() {
	m.food_stored = nil
	m.addfood_stored = nil
}

// SetWoodLimit sets the "wood_limit" field.
func (m *CityMutation) SetWoodLimit(i int) {
	m.wood_limit = &i
	m.addwood_limit = nil
}

// WoodLimit returns the value of the "wood_limit" field in the mutation.
func (m *CityMutation) WoodLimit() (r int, exists bool) {
	v := m.wood_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldWoodLimit returns the old "wood_limit" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldWoodLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWoodLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWoodLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWoodLimit: %w", err)
	}
	return oldValue.WoodLimit, nil
}

// AddWoodLimit adds i to the "wood_limit" field.
func (m *CityMutation) AddWoodLimit(i int) {
	if m.addwood_limit != nil {
		*m.addwood_limit += i
	} else {
		m.addwood_limit = &i
	}
}

// AddedWoodLimit returns the value that was added to the "wood_limit" field in this mutation.
func (m *CityMutation) AddedWoodLimit() (r int, exists bool) {
	v := m.addwood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodLimit resets all changes to the "wood_limit" field.
func (m *CityMutation) ResetWoodLimit() {
	m.wood_limit = nil
	m.addwood_limit = nil
}

// SetStoneLimit sets the "stone_limit" field.
func (m *CityMutation) SetStoneLimit(i int) {
	m.stone_limit = &i
	m.addstone_limit = nil
}

// StoneLimit returns the value of the "stone_limit" field in the mutation.
func (m *CityMutation) StoneLimit() (r int, exists bool) {
	v := m.stone_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldStoneLimit returns the old "stone_limit" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldStoneLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoneLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoneLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoneLimit: %w", err)
	}
	return oldValue.StoneLimit, nil
}

// AddStoneLimit adds i to the "stone_limit" field.
func (m *CityMutation) AddStoneLimit(i int) {
	if m.addstone_limit != nil {
		*m.addstone_limit += i
	} else {
		m.addstone_limit = &i
	}
}

// AddedStoneLimit returns the value that was added to the "stone_limit" field in this mutation.
func (m *CityMutation) AddedStoneLimit() (r int, exists bool) {
	v := m.addstone_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneLimit resets all changes to the "stone_limit" field.
func (m *CityMutation) ResetStoneLimit() {
	m.stone_limit = nil
	m.addstone_limit = nil
}

// SetIronLimit sets the "iron_limit" field.
func (m *CityMutation) SetIronLimit(i int) {
	m.iron_limit = &i
	m.addiron_limit = nil
}

// IronLimit returns the value of the "iron_limit" field in the mutation.
func (m *CityMutation) IronLimit() (r int, exists bool) {
	v := m.iron_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldIronLimit returns the old "iron_limit" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldIronLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIronLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIronLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIronLimit: %w", err)
	}
	return oldValue.IronLimit, nil
}

// AddIronLimit adds i to the "iron_limit" field.
func (m *CityMutation) AddIronLimit(i int) {
	if m.addiron_limit != nil {
		*m.addiron_limit += i
	} else {
		m.addiron_limit = &i
	}
}

// AddedIronLimit returns the value that was added to the "iron_limit" field in this mutation.
func (m *CityMutation) AddedIronLimit() (r int, exists bool) {
	v := m.addiron_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronLimit resets all changes to the "iron_limit" field.
func (m *CityMutation) ResetIronLimit() {
	m.iron_limit = nil
	m.addiron_limit = nil
}

// SetFoodLimit sets the "food_limit" field.
func (m *CityMutation) SetFoodLimit(i int) {
	m.food_limit = &i
	m.addfood_limit = nil
}

// FoodLimit returns the value of the "food_limit" field in the mutation.
func (m *CityMutation) FoodLimit() (r int, exists bool) {
	v := m.food_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldFoodLimit returns the old "food_limit" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldFoodLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFoodLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFoodLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFoodLimit: %w", err)
	}
	return oldValue.FoodLimit, nil
}

// AddFoodLimit adds i to the "food_limit" field.
func (m *CityMutation) AddFoodLimit(i int) {
	if m.addfood_limit != nil {
		*m.addfood_limit += i
	} else {
		m.addfood_limit = &i
	}
}

// AddedFoodLimit returns the value that was added to the "food_limit" field in this mutation.
func (m *CityMutation) AddedFoodLimit() (r int, exists bool) {
	v := m.addfood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodLimit resets all changes to the "food_limit" field.
func (m *CityMutation) ResetFoodLimit() {
	m.food_limit = nil
	m.addfood_limit = nil
}

// SetQueueTime sets the "queue_time" field.
func (m *CityMutation) SetQueueTime(t time.Time) {
	m.queue_time = &t
}

// QueueTime returns the value of the "queue_time" field in the mutation.
func (m *CityMutation) QueueTime() (r time.Time, exists bool) {
	v := m.queue_time
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueTime returns the old "queue_time" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldQueueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueTime: %w", err)
	}
	return oldValue.QueueTime, nil
}

// ResetQueueTime resets all changes to the "queue_time" field.
func (m *CityMutation) ResetQueueTime() {
	m.queue_time = nil
}

// SetConstructionSpeed sets the "construction_speed" field.
func (m *CityMutation) SetConstructionSpeed(i int) {
	m.construction_speed = &i
	m.addconstruction_speed = nil
}

// ConstructionSpeed returns the value of the "construction_speed" field in the mutation.
func (m *CityMutation) ConstructionSpeed() (r int, exists bool) {
	v := m.construction_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionSpeed returns the old "construction_speed" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldConstructionSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionSpeed: %w", err)
	}
	return oldValue.ConstructionSpeed, nil
}

// AddConstructionSpeed adds i to the "construction_speed" field.
func (m *CityMutation) AddConstructionSpeed(i int) {
	if m.addconstruction_speed != nil {
		*m.addconstruction_speed += i
	} else {
		m.addconstruction_speed = &i
	}
}

// AddedConstructionSpeed returns the value that was added to the "construction_speed" field in this mutation.
func (m *CityMutation) AddedConstructionSpeed() (r int, exists bool) {
	v := m.addconstruction_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetConstructionSpeed resets all changes to the "construction_speed" field.
func (m *CityMutation) ResetConstructionSpeed() {
	m.construction_speed = nil
	m.addconstruction_speed = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CityMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CityMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CityMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CityMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CityMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddConstructionIDs adds the "constructions" edge to the Construction entity by ids.
func (m *CityMutation) AddConstructionIDs(ids ...int) {
	if m.constructions == nil {
		m.constructions = make(map[int]struct{})
	}
	for i := range ids {
		m.constructions[ids[i]] = struct{}{}
	}
}

// ClearConstructions clears the "constructions" edge to the Construction entity.
func (m *CityMutation) ClearConstructions() {
	m.clearedconstructions = true
}

// ConstructionsCleared reports if the "constructions" edge to the Construction entity was cleared.
func (m *CityMutation) ConstructionsCleared() bool {
	return m.clearedconstructions
}

// RemoveConstructionIDs removes the "constructions" edge to the Construction entity by IDs.
func (m *CityMutation) RemoveConstructionIDs(ids ...int) {
	if m.removedconstructions == nil {
		m.removedconstructions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.constructions, ids[i])
		m.removedconstructions[ids[i]] = struct{}{}
	}
}

// RemovedConstructions returns the removed IDs of the "constructions" edge to the Construction entity.
func (m *CityMutation) RemovedConstructionsIDs() (ids []int) {
	for id := range m.removedconstructions {
		ids = append(ids, id)
	}
	return
}

// ConstructionsIDs returns the "constructions" edge IDs in the mutation.
func (m *CityMutation) ConstructionsIDs() (ids []int) {
	for id := range m.constructions {
		ids = append(ids, id)
	}
	return
}

// ResetConstructions resets all changes to the "constructions" edge.
func (m *CityMutation) ResetConstructions() {
	m.constructions = nil
	m.clearedconstructions = false
	m.removedconstructions = nil
}

// AddQueueIDs adds the "queue" edge to the Queue entity by ids.
func (m *CityMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// ClearQueue clears the "queue" edge to the Queue entity.
func (m *CityMutation) ClearQueue() {
	m.clearedqueue = true
}

// QueueCleared reports if the "queue" edge to the Queue entity was cleared.
func (m *CityMutation) QueueCleared() bool {
	return m.clearedqueue
}

// RemoveQueueIDs removes the "queue" edge to the Queue entity by IDs.
func (m *CityMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.queue, ids[i])
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed IDs of the "queue" edge to the Queue entity.
func (m *CityMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the "queue" edge IDs in the mutation.
func (m *CityMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue resets all changes to the "queue" edge.
func (m *CityMutation) ResetQueue() {
	m.queue = nil
	m.clearedqueue = false
	m.removedqueue = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.x != nil {
		fields = append(fields, city.FieldX)
	}
	if m.y != nil {
		fields = append(fields, city.FieldY)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.points != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.wood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.stone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.iron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.food_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.wood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.stone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.iron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.food_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.wood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.stone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.iron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.food_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.queue_time != nil {
		fields = append(fields, city.FieldQueueTime)
	}
	if m.construction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.X()
	case city.FieldY:
		return m.Y()
	case city.FieldName:
		return m.Name()
	case city.FieldPoints:
		return m.Points()
	case city.FieldWoodProduction:
		return m.WoodProduction()
	case city.FieldStoneProduction:
		return m.StoneProduction()
	case city.FieldIronProduction:
		return m.IronProduction()
	case city.FieldFoodProduction:
		return m.FoodProduction()
	case city.FieldWoodStored:
		return m.WoodStored()
	case city.FieldStoneStored:
		return m.StoneStored()
	case city.FieldIronStored:
		return m.IronStored()
	case city.FieldFoodStored:
		return m.FoodStored()
	case city.FieldWoodLimit:
		return m.WoodLimit()
	case city.FieldStoneLimit:
		return m.StoneLimit()
	case city.FieldIronLimit:
		return m.IronLimit()
	case city.FieldFoodLimit:
		return m.FoodLimit()
	case city.FieldQueueTime:
		return m.QueueTime()
	case city.FieldConstructionSpeed:
		return m.ConstructionSpeed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldX:
		return m.OldX(ctx)
	case city.FieldY:
		return m.OldY(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldPoints:
		return m.OldPoints(ctx)
	case city.FieldWoodProduction:
		return m.OldWoodProduction(ctx)
	case city.FieldStoneProduction:
		return m.OldStoneProduction(ctx)
	case city.FieldIronProduction:
		return m.OldIronProduction(ctx)
	case city.FieldFoodProduction:
		return m.OldFoodProduction(ctx)
	case city.FieldWoodStored:
		return m.OldWoodStored(ctx)
	case city.FieldStoneStored:
		return m.OldStoneStored(ctx)
	case city.FieldIronStored:
		return m.OldIronStored(ctx)
	case city.FieldFoodStored:
		return m.OldFoodStored(ctx)
	case city.FieldWoodLimit:
		return m.OldWoodLimit(ctx)
	case city.FieldStoneLimit:
		return m.OldStoneLimit(ctx)
	case city.FieldIronLimit:
		return m.OldIronLimit(ctx)
	case city.FieldFoodLimit:
		return m.OldFoodLimit(ctx)
	case city.FieldQueueTime:
		return m.OldQueueTime(ctx)
	case city.FieldConstructionSpeed:
		return m.OldConstructionSpeed(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodLimit(v)
		return nil
	case city.FieldQueueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueTime(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, city.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, city.FieldY)
	}
	if m.addpoints != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.addwood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.addstone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.addiron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.addfood_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.addwood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.addstone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.addiron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.addfood_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.addwood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.addstone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.addiron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.addfood_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.addconstruction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.AddedX()
	case city.FieldY:
		return m.AddedY()
	case city.FieldPoints:
		return m.AddedPoints()
	case city.FieldWoodProduction:
		return m.AddedWoodProduction()
	case city.FieldStoneProduction:
		return m.AddedStoneProduction()
	case city.FieldIronProduction:
		return m.AddedIronProduction()
	case city.FieldFoodProduction:
		return m.AddedFoodProduction()
	case city.FieldWoodStored:
		return m.AddedWoodStored()
	case city.FieldStoneStored:
		return m.AddedStoneStored()
	case city.FieldIronStored:
		return m.AddedIronStored()
	case city.FieldFoodStored:
		return m.AddedFoodStored()
	case city.FieldWoodLimit:
		return m.AddedWoodLimit()
	case city.FieldStoneLimit:
		return m.AddedStoneLimit()
	case city.FieldIronLimit:
		return m.AddedIronLimit()
	case city.FieldFoodLimit:
		return m.AddedFoodLimit()
	case city.FieldConstructionSpeed:
		return m.AddedConstructionSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodLimit(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldX:
		m.ResetX()
		return nil
	case city.FieldY:
		m.ResetY()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldPoints:
		m.ResetPoints()
		return nil
	case city.FieldWoodProduction:
		m.ResetWoodProduction()
		return nil
	case city.FieldStoneProduction:
		m.ResetStoneProduction()
		return nil
	case city.FieldIronProduction:
		m.ResetIronProduction()
		return nil
	case city.FieldFoodProduction:
		m.ResetFoodProduction()
		return nil
	case city.FieldWoodStored:
		m.ResetWoodStored()
		return nil
	case city.FieldStoneStored:
		m.ResetStoneStored()
		return nil
	case city.FieldIronStored:
		m.ResetIronStored()
		return nil
	case city.FieldFoodStored:
		m.ResetFoodStored()
		return nil
	case city.FieldWoodLimit:
		m.ResetWoodLimit()
		return nil
	case city.FieldStoneLimit:
		m.ResetStoneLimit()
		return nil
	case city.FieldIronLimit:
		m.ResetIronLimit()
		return nil
	case city.FieldFoodLimit:
		m.ResetFoodLimit()
		return nil
	case city.FieldQueueTime:
		m.ResetQueueTime()
		return nil
	case city.FieldConstructionSpeed:
		m.ResetConstructionSpeed()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, city.EdgeOwner)
	}
	if m.constructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.queue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.constructions))
		for id := range m.constructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedconstructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.removedqueue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.removedconstructions))
		for id := range m.removedconstructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, city.EdgeOwner)
	}
	if m.clearedconstructions {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.clearedqueue {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeOwner:
		return m.clearedowner
	case city.EdgeConstructions:
		return m.clearedconstructions
	case city.EdgeQueue:
		return m.clearedqueue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ResetOwner()
		return nil
	case city.EdgeConstructions:
		m.ResetConstructions()
		return nil
	case city.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// ConstructionMutation represents an operation that mutates the Construction nodes in the graph.
type ConstructionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	x                 *int
	addx              *int
	y                 *int
	addy              *int
	raw_production    *int
	addraw_production *int
	_type             *int
	add_type          *int
	level             *int
	addlevel          *int
	modifier          *float64
	addmodifier       *float64
	need_refresh      *bool
	clearedFields     map[string]struct{}
	city              *int
	clearedcity       bool
	queue             map[int]struct{}
	removedqueue      map[int]struct{}
	clearedqueue      bool
	done              bool
	oldValue          func(context.Context) (*Construction, error)
	predicates        []predicate.Construction
}

var _ ent.Mutation = (*ConstructionMutation)(nil)

// constructionOption allows management of the mutation configuration using functional options.
type constructionOption func(*ConstructionMutation)

// newConstructionMutation creates new mutation for the Construction entity.
func newConstructionMutation(c config, op Op, opts ...constructionOption) *ConstructionMutation {
	m := &ConstructionMutation{
		config:        c,
		op:            op,
		typ:           TypeConstruction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConstructionID sets the ID field of the mutation.
func withConstructionID(id int) constructionOption {
	return func(m *ConstructionMutation) {
		var (
			err   error
			once  sync.Once
			value *Construction
		)
		m.oldValue = func(ctx context.Context) (*Construction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Construction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConstruction sets the old Construction of the mutation.
func withConstruction(node *Construction) constructionOption {
	return func(m *ConstructionMutation) {
		m.oldValue = func(context.Context) (*Construction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConstructionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConstructionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConstructionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConstructionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Construction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetX sets the "x" field.
func (m *ConstructionMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *ConstructionMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *ConstructionMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *ConstructionMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *ConstructionMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *ConstructionMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *ConstructionMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *ConstructionMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *ConstructionMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *ConstructionMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetRawProduction sets the "raw_production" field.
func (m *ConstructionMutation) SetRawProduction(i int) {
	m.raw_production = &i
	m.addraw_production = nil
}

// RawProduction returns the value of the "raw_production" field in the mutation.
func (m *ConstructionMutation) RawProduction() (r int, exists bool) {
	v := m.raw_production
	if v == nil {
		return
	}
	return *v, true
}

// OldRawProduction returns the old "raw_production" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldRawProduction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawProduction: %w", err)
	}
	return oldValue.RawProduction, nil
}

// AddRawProduction adds i to the "raw_production" field.
func (m *ConstructionMutation) AddRawProduction(i int) {
	if m.addraw_production != nil {
		*m.addraw_production += i
	} else {
		m.addraw_production = &i
	}
}

// AddedRawProduction returns the value that was added to the "raw_production" field in this mutation.
func (m *ConstructionMutation) AddedRawProduction() (r int, exists bool) {
	v := m.addraw_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetRawProduction resets all changes to the "raw_production" field.
func (m *ConstructionMutation) ResetRawProduction() {
	m.raw_production = nil
	m.addraw_production = nil
}

// SetType sets the "type" field.
func (m *ConstructionMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConstructionMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ConstructionMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ConstructionMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ConstructionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLevel sets the "level" field.
func (m *ConstructionMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *ConstructionMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *ConstructionMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *ConstructionMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *ConstructionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetModifier sets the "modifier" field.
func (m *ConstructionMutation) SetModifier(f float64) {
	m.modifier = &f
	m.addmodifier = nil
}

// Modifier returns the value of the "modifier" field in the mutation.
func (m *ConstructionMutation) Modifier() (r float64, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifier returns the old "modifier" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldModifier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifier: %w", err)
	}
	return oldValue.Modifier, nil
}

// AddModifier adds f to the "modifier" field.
func (m *ConstructionMutation) AddModifier(f float64) {
	if m.addmodifier != nil {
		*m.addmodifier += f
	} else {
		m.addmodifier = &f
	}
}

// AddedModifier returns the value that was added to the "modifier" field in this mutation.
func (m *ConstructionMutation) AddedModifier() (r float64, exists bool) {
	v := m.addmodifier
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifier resets all changes to the "modifier" field.
func (m *ConstructionMutation) ResetModifier() {
	m.modifier = nil
	m.addmodifier = nil
}

// SetNeedRefresh sets the "need_refresh" field.
func (m *ConstructionMutation) SetNeedRefresh(b bool) {
	m.need_refresh = &b
}

// NeedRefresh returns the value of the "need_refresh" field in the mutation.
func (m *ConstructionMutation) NeedRefresh() (r bool, exists bool) {
	v := m.need_refresh
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedRefresh returns the old "need_refresh" field's value of the Construction entity.
// If the Construction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstructionMutation) OldNeedRefresh(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedRefresh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedRefresh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedRefresh: %w", err)
	}
	return oldValue.NeedRefresh, nil
}

// ResetNeedRefresh resets all changes to the "need_refresh" field.
func (m *ConstructionMutation) ResetNeedRefresh() {
	m.need_refresh = nil
}

// SetCityID sets the "city" edge to the City entity by id.
func (m *ConstructionMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the "city" edge to the City entity.
func (m *ConstructionMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ConstructionMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the "city" edge ID in the mutation.
func (m *ConstructionMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ConstructionMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ConstructionMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddQueueIDs adds the "queue" edge to the Queue entity by ids.
func (m *ConstructionMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// ClearQueue clears the "queue" edge to the Queue entity.
func (m *ConstructionMutation) ClearQueue() {
	m.clearedqueue = true
}

// QueueCleared reports if the "queue" edge to the Queue entity was cleared.
func (m *ConstructionMutation) QueueCleared() bool {
	return m.clearedqueue
}

// RemoveQueueIDs removes the "queue" edge to the Queue entity by IDs.
func (m *ConstructionMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.queue, ids[i])
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed IDs of the "queue" edge to the Queue entity.
func (m *ConstructionMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the "queue" edge IDs in the mutation.
func (m *ConstructionMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue resets all changes to the "queue" edge.
func (m *ConstructionMutation) ResetQueue() {
	m.queue = nil
	m.clearedqueue = false
	m.removedqueue = nil
}

// Where appends a list predicates to the ConstructionMutation builder.
func (m *ConstructionMutation) Where(ps ...predicate.Construction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConstructionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConstructionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Construction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConstructionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConstructionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Construction).
func (m *ConstructionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConstructionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.x != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.y != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.raw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m._type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.level != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.modifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	if m.need_refresh != nil {
		fields = append(fields, construction.FieldNeedRefresh)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConstructionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.X()
	case construction.FieldY:
		return m.Y()
	case construction.FieldRawProduction:
		return m.RawProduction()
	case construction.FieldType:
		return m.GetType()
	case construction.FieldLevel:
		return m.Level()
	case construction.FieldModifier:
		return m.Modifier()
	case construction.FieldNeedRefresh:
		return m.NeedRefresh()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConstructionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case construction.FieldX:
		return m.OldX(ctx)
	case construction.FieldY:
		return m.OldY(ctx)
	case construction.FieldRawProduction:
		return m.OldRawProduction(ctx)
	case construction.FieldType:
		return m.OldType(ctx)
	case construction.FieldLevel:
		return m.OldLevel(ctx)
	case construction.FieldModifier:
		return m.OldModifier(ctx)
	case construction.FieldNeedRefresh:
		return m.OldNeedRefresh(ctx)
	}
	return nil, fmt.Errorf("unknown Construction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConstructionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case construction.FieldNeedRefresh:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedRefresh(v)
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConstructionMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.addraw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m.add_type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.addlevel != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.addmodifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConstructionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.AddedX()
	case construction.FieldY:
		return m.AddedY()
	case construction.FieldRawProduction:
		return m.AddedRawProduction()
	case construction.FieldType:
		return m.AddedType()
	case construction.FieldLevel:
		return m.AddedLevel()
	case construction.FieldModifier:
		return m.AddedModifier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConstructionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRawProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifier(v)
		return nil
	}
	return fmt.Errorf("unknown Construction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConstructionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConstructionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConstructionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Construction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConstructionMutation) ResetField(name string) error {
	switch name {
	case construction.FieldX:
		m.ResetX()
		return nil
	case construction.FieldY:
		m.ResetY()
		return nil
	case construction.FieldRawProduction:
		m.ResetRawProduction()
		return nil
	case construction.FieldType:
		m.ResetType()
		return nil
	case construction.FieldLevel:
		m.ResetLevel()
		return nil
	case construction.FieldModifier:
		m.ResetModifier()
		return nil
	case construction.FieldNeedRefresh:
		m.ResetNeedRefresh()
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConstructionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.city != nil {
		edges = append(edges, construction.EdgeCity)
	}
	if m.queue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConstructionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConstructionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedqueue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConstructionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConstructionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcity {
		edges = append(edges, construction.EdgeCity)
	}
	if m.clearedqueue {
		edges = append(edges, construction.EdgeQueue)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConstructionMutation) EdgeCleared(name string) bool {
	switch name {
	case construction.EdgeCity:
		return m.clearedcity
	case construction.EdgeQueue:
		return m.clearedqueue
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConstructionMutation) ClearEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Construction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConstructionMutation) ResetEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ResetCity()
		return nil
	case construction.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown Construction edge %s", name)
}

// QueueMutation represents an operation that mutates the Queue nodes in the graph.
type QueueMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	completion          *time.Time
	action              *int
	addaction           *int
	_order              *int
	add_order           *int
	clearedFields       map[string]struct{}
	city                *int
	clearedcity         bool
	construction        *int
	clearedconstruction bool
	done                bool
	oldValue            func(context.Context) (*Queue, error)
	predicates          []predicate.Queue
}

var _ ent.Mutation = (*QueueMutation)(nil)

// queueOption allows management of the mutation configuration using functional options.
type queueOption func(*QueueMutation)

// newQueueMutation creates new mutation for the Queue entity.
func newQueueMutation(c config, op Op, opts ...queueOption) *QueueMutation {
	m := &QueueMutation{
		config:        c,
		op:            op,
		typ:           TypeQueue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQueueID sets the ID field of the mutation.
func withQueueID(id int) queueOption {
	return func(m *QueueMutation) {
		var (
			err   error
			once  sync.Once
			value *Queue
		)
		m.oldValue = func(ctx context.Context) (*Queue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Queue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQueue sets the old Queue of the mutation.
func withQueue(node *Queue) queueOption {
	return func(m *QueueMutation) {
		m.oldValue = func(context.Context) (*Queue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QueueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QueueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Queue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompletion sets the "completion" field.
func (m *QueueMutation) SetCompletion(t time.Time) {
	m.completion = &t
}

// Completion returns the value of the "completion" field in the mutation.
func (m *QueueMutation) Completion() (r time.Time, exists bool) {
	v := m.completion
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletion returns the old "completion" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldCompletion(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletion: %w", err)
	}
	return oldValue.Completion, nil
}

// ResetCompletion resets all changes to the "completion" field.
func (m *QueueMutation) ResetCompletion() {
	m.completion = nil
}

// SetAction sets the "action" field.
func (m *QueueMutation) SetAction(i int) {
	m.action = &i
	m.addaction = nil
}

// Action returns the value of the "action" field in the mutation.
func (m *QueueMutation) Action() (r int, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldAction(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// AddAction adds i to the "action" field.
func (m *QueueMutation) AddAction(i int) {
	if m.addaction != nil {
		*m.addaction += i
	} else {
		m.addaction = &i
	}
}

// AddedAction returns the value that was added to the "action" field in this mutation.
func (m *QueueMutation) AddedAction() (r int, exists bool) {
	v := m.addaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction resets all changes to the "action" field.
func (m *QueueMutation) ResetAction() {
	m.action = nil
	m.addaction = nil
}

// SetOrder sets the "order" field.
func (m *QueueMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *QueueMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Queue entity.
// If the Queue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QueueMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *QueueMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *QueueMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *QueueMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetCityID sets the "city" edge to the City entity by id.
func (m *QueueMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the "city" edge to the City entity.
func (m *QueueMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *QueueMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the "city" edge ID in the mutation.
func (m *QueueMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *QueueMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetConstructionID sets the "construction" edge to the Construction entity by id.
func (m *QueueMutation) SetConstructionID(id int) {
	m.construction = &id
}

// ClearConstruction clears the "construction" edge to the Construction entity.
func (m *QueueMutation) ClearConstruction() {
	m.clearedconstruction = true
}

// ConstructionCleared reports if the "construction" edge to the Construction entity was cleared.
func (m *QueueMutation) ConstructionCleared() bool {
	return m.clearedconstruction
}

// ConstructionID returns the "construction" edge ID in the mutation.
func (m *QueueMutation) ConstructionID() (id int, exists bool) {
	if m.construction != nil {
		return *m.construction, true
	}
	return
}

// ConstructionIDs returns the "construction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConstructionID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) ConstructionIDs() (ids []int) {
	if id := m.construction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConstruction resets all changes to the "construction" edge.
func (m *QueueMutation) ResetConstruction() {
	m.construction = nil
	m.clearedconstruction = false
}

// Where appends a list predicates to the QueueMutation builder.
func (m *QueueMutation) Where(ps ...predicate.Queue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QueueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QueueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Queue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QueueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QueueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Queue).
func (m *QueueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QueueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.completion != nil {
		fields = append(fields, queue.FieldCompletion)
	}
	if m.action != nil {
		fields = append(fields, queue.FieldAction)
	}
	if m._order != nil {
		fields = append(fields, queue.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QueueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldCompletion:
		return m.Completion()
	case queue.FieldAction:
		return m.Action()
	case queue.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QueueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case queue.FieldCompletion:
		return m.OldCompletion(ctx)
	case queue.FieldAction:
		return m.OldAction(ctx)
	case queue.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Queue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queue.FieldCompletion:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletion(v)
		return nil
	case queue.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case queue.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QueueMutation) AddedFields() []string {
	var fields []string
	if m.addaction != nil {
		fields = append(fields, queue.FieldAction)
	}
	if m.add_order != nil {
		fields = append(fields, queue.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QueueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldAction:
		return m.AddedAction()
	case queue.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QueueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case queue.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	case queue.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Queue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QueueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QueueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Queue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QueueMutation) ResetField(name string) error {
	switch name {
	case queue.FieldCompletion:
		m.ResetCompletion()
		return nil
	case queue.FieldAction:
		m.ResetAction()
		return nil
	case queue.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QueueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.city != nil {
		edges = append(edges, queue.EdgeCity)
	}
	if m.construction != nil {
		edges = append(edges, queue.EdgeConstruction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QueueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case queue.EdgeConstruction:
		if id := m.construction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QueueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QueueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QueueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcity {
		edges = append(edges, queue.EdgeCity)
	}
	if m.clearedconstruction {
		edges = append(edges, queue.EdgeConstruction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QueueMutation) EdgeCleared(name string) bool {
	switch name {
	case queue.EdgeCity:
		return m.clearedcity
	case queue.EdgeConstruction:
		return m.clearedconstruction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QueueMutation) ClearEdge(name string) error {
	switch name {
	case queue.EdgeCity:
		m.ClearCity()
		return nil
	case queue.EdgeConstruction:
		m.ClearConstruction()
		return nil
	}
	return fmt.Errorf("unknown Queue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QueueMutation) ResetEdge(name string) error {
	switch name {
	case queue.EdgeCity:
		m.ResetCity()
		return nil
	case queue.EdgeConstruction:
		m.ResetConstruction()
		return nil
	}
	return fmt.Errorf("unknown Queue edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	email            *string
	password_hash    *string
	gold             *int
	addgold          *int
	diamonds         *int
	adddiamonds      *int
	darkwood         *int
	adddarkwood      *int
	runestone        *int
	addrunestone     *int
	veritium         *int
	addveritium      *int
	trueseed         *int
	addtrueseed      *int
	rank             *int
	addrank          *int
	alliance_rank    *int
	addalliance_rank *int
	clearedFields    map[string]struct{}
	cities           map[int]struct{}
	removedcities    map[int]struct{}
	clearedcities    bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetGold sets the "gold" field.
func (m *UserMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the value of the "gold" field in the mutation.
func (m *UserMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// OldGold returns the old "gold" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGold: %w", err)
	}
	return oldValue.Gold, nil
}

// AddGold adds i to the "gold" field.
func (m *UserMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the "gold" field in this mutation.
func (m *UserMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold resets all changes to the "gold" field.
func (m *UserMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetDiamonds sets the "diamonds" field.
func (m *UserMutation) SetDiamonds(i int) {
	m.diamonds = &i
	m.adddiamonds = nil
}

// Diamonds returns the value of the "diamonds" field in the mutation.
func (m *UserMutation) Diamonds() (r int, exists bool) {
	v := m.diamonds
	if v == nil {
		return
	}
	return *v, true
}

// OldDiamonds returns the old "diamonds" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDiamonds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiamonds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiamonds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiamonds: %w", err)
	}
	return oldValue.Diamonds, nil
}

// AddDiamonds adds i to the "diamonds" field.
func (m *UserMutation) AddDiamonds(i int) {
	if m.adddiamonds != nil {
		*m.adddiamonds += i
	} else {
		m.adddiamonds = &i
	}
}

// AddedDiamonds returns the value that was added to the "diamonds" field in this mutation.
func (m *UserMutation) AddedDiamonds() (r int, exists bool) {
	v := m.adddiamonds
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiamonds resets all changes to the "diamonds" field.
func (m *UserMutation) ResetDiamonds() {
	m.diamonds = nil
	m.adddiamonds = nil
}

// SetDarkwood sets the "darkwood" field.
func (m *UserMutation) SetDarkwood(i int) {
	m.darkwood = &i
	m.adddarkwood = nil
}

// Darkwood returns the value of the "darkwood" field in the mutation.
func (m *UserMutation) Darkwood() (r int, exists bool) {
	v := m.darkwood
	if v == nil {
		return
	}
	return *v, true
}

// OldDarkwood returns the old "darkwood" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDarkwood(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDarkwood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDarkwood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDarkwood: %w", err)
	}
	return oldValue.Darkwood, nil
}

// AddDarkwood adds i to the "darkwood" field.
func (m *UserMutation) AddDarkwood(i int) {
	if m.adddarkwood != nil {
		*m.adddarkwood += i
	} else {
		m.adddarkwood = &i
	}
}

// AddedDarkwood returns the value that was added to the "darkwood" field in this mutation.
func (m *UserMutation) AddedDarkwood() (r int, exists bool) {
	v := m.adddarkwood
	if v == nil {
		return
	}
	return *v, true
}

// ResetDarkwood resets all changes to the "darkwood" field.
func (m *UserMutation) ResetDarkwood() {
	m.darkwood = nil
	m.adddarkwood = nil
}

// SetRunestone sets the "runestone" field.
func (m *UserMutation) SetRunestone(i int) {
	m.runestone = &i
	m.addrunestone = nil
}

// Runestone returns the value of the "runestone" field in the mutation.
func (m *UserMutation) Runestone() (r int, exists bool) {
	v := m.runestone
	if v == nil {
		return
	}
	return *v, true
}

// OldRunestone returns the old "runestone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRunestone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunestone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunestone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunestone: %w", err)
	}
	return oldValue.Runestone, nil
}

// AddRunestone adds i to the "runestone" field.
func (m *UserMutation) AddRunestone(i int) {
	if m.addrunestone != nil {
		*m.addrunestone += i
	} else {
		m.addrunestone = &i
	}
}

// AddedRunestone returns the value that was added to the "runestone" field in this mutation.
func (m *UserMutation) AddedRunestone() (r int, exists bool) {
	v := m.addrunestone
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunestone resets all changes to the "runestone" field.
func (m *UserMutation) ResetRunestone() {
	m.runestone = nil
	m.addrunestone = nil
}

// SetVeritium sets the "veritium" field.
func (m *UserMutation) SetVeritium(i int) {
	m.veritium = &i
	m.addveritium = nil
}

// Veritium returns the value of the "veritium" field in the mutation.
func (m *UserMutation) Veritium() (r int, exists bool) {
	v := m.veritium
	if v == nil {
		return
	}
	return *v, true
}

// OldVeritium returns the old "veritium" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVeritium(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVeritium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVeritium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVeritium: %w", err)
	}
	return oldValue.Veritium, nil
}

// AddVeritium adds i to the "veritium" field.
func (m *UserMutation) AddVeritium(i int) {
	if m.addveritium != nil {
		*m.addveritium += i
	} else {
		m.addveritium = &i
	}
}

// AddedVeritium returns the value that was added to the "veritium" field in this mutation.
func (m *UserMutation) AddedVeritium() (r int, exists bool) {
	v := m.addveritium
	if v == nil {
		return
	}
	return *v, true
}

// ResetVeritium resets all changes to the "veritium" field.
func (m *UserMutation) ResetVeritium() {
	m.veritium = nil
	m.addveritium = nil
}

// SetTrueseed sets the "trueseed" field.
func (m *UserMutation) SetTrueseed(i int) {
	m.trueseed = &i
	m.addtrueseed = nil
}

// Trueseed returns the value of the "trueseed" field in the mutation.
func (m *UserMutation) Trueseed() (r int, exists bool) {
	v := m.trueseed
	if v == nil {
		return
	}
	return *v, true
}

// OldTrueseed returns the old "trueseed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTrueseed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrueseed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrueseed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrueseed: %w", err)
	}
	return oldValue.Trueseed, nil
}

// AddTrueseed adds i to the "trueseed" field.
func (m *UserMutation) AddTrueseed(i int) {
	if m.addtrueseed != nil {
		*m.addtrueseed += i
	} else {
		m.addtrueseed = &i
	}
}

// AddedTrueseed returns the value that was added to the "trueseed" field in this mutation.
func (m *UserMutation) AddedTrueseed() (r int, exists bool) {
	v := m.addtrueseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrueseed resets all changes to the "trueseed" field.
func (m *UserMutation) ResetTrueseed() {
	m.trueseed = nil
	m.addtrueseed = nil
}

// SetRank sets the "rank" field.
func (m *UserMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *UserMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *UserMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *UserMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *UserMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetAllianceRank sets the "alliance_rank" field.
func (m *UserMutation) SetAllianceRank(i int) {
	m.alliance_rank = &i
	m.addalliance_rank = nil
}

// AllianceRank returns the value of the "alliance_rank" field in the mutation.
func (m *UserMutation) AllianceRank() (r int, exists bool) {
	v := m.alliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// OldAllianceRank returns the old "alliance_rank" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAllianceRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllianceRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllianceRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllianceRank: %w", err)
	}
	return oldValue.AllianceRank, nil
}

// AddAllianceRank adds i to the "alliance_rank" field.
func (m *UserMutation) AddAllianceRank(i int) {
	if m.addalliance_rank != nil {
		*m.addalliance_rank += i
	} else {
		m.addalliance_rank = &i
	}
}

// AddedAllianceRank returns the value that was added to the "alliance_rank" field in this mutation.
func (m *UserMutation) AddedAllianceRank() (r int, exists bool) {
	v := m.addalliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllianceRank resets all changes to the "alliance_rank" field.
func (m *UserMutation) ResetAllianceRank() {
	m.alliance_rank = nil
	m.addalliance_rank = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *UserMutation) AddCityIDs(ids ...int) {
	if m.cities == nil {
		m.cities = make(map[int]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *UserMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *UserMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *UserMutation) RemoveCityIDs(ids ...int) {
	if m.removedcities == nil {
		m.removedcities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *UserMutation) RemovedCitiesIDs() (ids []int) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *UserMutation) CitiesIDs() (ids []int) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *UserMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.gold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.diamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.darkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.runestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.veritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.trueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.rank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.alliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldGold:
		return m.Gold()
	case user.FieldDiamonds:
		return m.Diamonds()
	case user.FieldDarkwood:
		return m.Darkwood()
	case user.FieldRunestone:
		return m.Runestone()
	case user.FieldVeritium:
		return m.Veritium()
	case user.FieldTrueseed:
		return m.Trueseed()
	case user.FieldRank:
		return m.Rank()
	case user.FieldAllianceRank:
		return m.AllianceRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldGold:
		return m.OldGold(ctx)
	case user.FieldDiamonds:
		return m.OldDiamonds(ctx)
	case user.FieldDarkwood:
		return m.OldDarkwood(ctx)
	case user.FieldRunestone:
		return m.OldRunestone(ctx)
	case user.FieldVeritium:
		return m.OldVeritium(ctx)
	case user.FieldTrueseed:
		return m.OldTrueseed(ctx)
	case user.FieldRank:
		return m.OldRank(ctx)
	case user.FieldAllianceRank:
		return m.OldAllianceRank(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.adddiamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.adddarkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.addrunestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.addveritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.addtrueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.addrank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.addalliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGold:
		return m.AddedGold()
	case user.FieldDiamonds:
		return m.AddedDiamonds()
	case user.FieldDarkwood:
		return m.AddedDarkwood()
	case user.FieldRunestone:
		return m.AddedRunestone()
	case user.FieldVeritium:
		return m.AddedVeritium()
	case user.FieldTrueseed:
		return m.AddedTrueseed()
	case user.FieldRank:
		return m.AddedRank()
	case user.FieldAllianceRank:
		return m.AddedAllianceRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldGold:
		m.ResetGold()
		return nil
	case user.FieldDiamonds:
		m.ResetDiamonds()
		return nil
	case user.FieldDarkwood:
		m.ResetDarkwood()
		return nil
	case user.FieldRunestone:
		m.ResetRunestone()
		return nil
	case user.FieldVeritium:
		m.ResetVeritium()
		return nil
	case user.FieldTrueseed:
		m.ResetTrueseed()
		return nil
	case user.FieldRank:
		m.ResetRank()
		return nil
	case user.FieldAllianceRank:
		m.ResetAllianceRank()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cities != nil {
		edges = append(edges, user.EdgeCities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcities != nil {
		edges = append(edges, user.EdgeCities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcities {
		edges = append(edges, user.EdgeCities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCities:
		return m.clearedcities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCities:
		m.ResetCities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

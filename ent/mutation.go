// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/joaopedrosgs/openlou/ent/city"
	"github.com/joaopedrosgs/openlou/ent/construction"
	"github.com/joaopedrosgs/openlou/ent/queue"
	"github.com/joaopedrosgs/openlou/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCity         = "City"
	TypeConstruction = "Construction"
	TypeQueue        = "Queue"
	TypeUser         = "User"
)

// CityMutation represents an operation that mutate the Cities
// nodes in the graph.
type CityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	x                     *int
	addx                  *int
	y                     *int
	addy                  *int
	name                  *string
	points                *int
	addpoints             *int
	wood_production       *int
	addwood_production    *int
	stone_production      *int
	addstone_production   *int
	iron_production       *int
	addiron_production    *int
	food_production       *int
	addfood_production    *int
	wood_stored           *int
	addwood_stored        *int
	stone_stored          *int
	addstone_stored       *int
	iron_stored           *int
	addiron_stored        *int
	food_stored           *int
	addfood_stored        *int
	wood_limit            *int
	addwood_limit         *int
	stone_limit           *int
	addstone_limit        *int
	iron_limit            *int
	addiron_limit         *int
	food_limit            *int
	addfood_limit         *int
	queue_time            *time.Time
	construction_speed    *int
	addconstruction_speed *int
	clearedFields         map[string]struct{}
	owner                 *int
	clearedowner          bool
	constructions         map[int]struct{}
	removedconstructions  map[int]struct{}
	queue                 map[int]struct{}
	removedqueue          map[int]struct{}
}

var _ ent.Mutation = (*CityMutation)(nil)

// newCityMutation creates new mutation for $n.Name.
func newCityMutation(c config, op Op) *CityMutation {
	return &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the x field.
func (m *CityMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the x value in the mutation.
func (m *CityMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// AddX adds i to x.
func (m *CityMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the x field in this mutation.
func (m *CityMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX reset all changes of the x field.
func (m *CityMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the y field.
func (m *CityMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the y value in the mutation.
func (m *CityMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// AddY adds i to y.
func (m *CityMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the y field in this mutation.
func (m *CityMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY reset all changes of the y field.
func (m *CityMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetName sets the name field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetPoints sets the points field.
func (m *CityMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the points value in the mutation.
func (m *CityMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// AddPoints adds i to points.
func (m *CityMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the points field in this mutation.
func (m *CityMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints reset all changes of the points field.
func (m *CityMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetWoodProduction sets the wood_production field.
func (m *CityMutation) SetWoodProduction(i int) {
	m.wood_production = &i
	m.addwood_production = nil
}

// WoodProduction returns the wood_production value in the mutation.
func (m *CityMutation) WoodProduction() (r int, exists bool) {
	v := m.wood_production
	if v == nil {
		return
	}
	return *v, true
}

// AddWoodProduction adds i to wood_production.
func (m *CityMutation) AddWoodProduction(i int) {
	if m.addwood_production != nil {
		*m.addwood_production += i
	} else {
		m.addwood_production = &i
	}
}

// AddedWoodProduction returns the value that was added to the wood_production field in this mutation.
func (m *CityMutation) AddedWoodProduction() (r int, exists bool) {
	v := m.addwood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodProduction reset all changes of the wood_production field.
func (m *CityMutation) ResetWoodProduction() {
	m.wood_production = nil
	m.addwood_production = nil
}

// SetStoneProduction sets the stone_production field.
func (m *CityMutation) SetStoneProduction(i int) {
	m.stone_production = &i
	m.addstone_production = nil
}

// StoneProduction returns the stone_production value in the mutation.
func (m *CityMutation) StoneProduction() (r int, exists bool) {
	v := m.stone_production
	if v == nil {
		return
	}
	return *v, true
}

// AddStoneProduction adds i to stone_production.
func (m *CityMutation) AddStoneProduction(i int) {
	if m.addstone_production != nil {
		*m.addstone_production += i
	} else {
		m.addstone_production = &i
	}
}

// AddedStoneProduction returns the value that was added to the stone_production field in this mutation.
func (m *CityMutation) AddedStoneProduction() (r int, exists bool) {
	v := m.addstone_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneProduction reset all changes of the stone_production field.
func (m *CityMutation) ResetStoneProduction() {
	m.stone_production = nil
	m.addstone_production = nil
}

// SetIronProduction sets the iron_production field.
func (m *CityMutation) SetIronProduction(i int) {
	m.iron_production = &i
	m.addiron_production = nil
}

// IronProduction returns the iron_production value in the mutation.
func (m *CityMutation) IronProduction() (r int, exists bool) {
	v := m.iron_production
	if v == nil {
		return
	}
	return *v, true
}

// AddIronProduction adds i to iron_production.
func (m *CityMutation) AddIronProduction(i int) {
	if m.addiron_production != nil {
		*m.addiron_production += i
	} else {
		m.addiron_production = &i
	}
}

// AddedIronProduction returns the value that was added to the iron_production field in this mutation.
func (m *CityMutation) AddedIronProduction() (r int, exists bool) {
	v := m.addiron_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronProduction reset all changes of the iron_production field.
func (m *CityMutation) ResetIronProduction() {
	m.iron_production = nil
	m.addiron_production = nil
}

// SetFoodProduction sets the food_production field.
func (m *CityMutation) SetFoodProduction(i int) {
	m.food_production = &i
	m.addfood_production = nil
}

// FoodProduction returns the food_production value in the mutation.
func (m *CityMutation) FoodProduction() (r int, exists bool) {
	v := m.food_production
	if v == nil {
		return
	}
	return *v, true
}

// AddFoodProduction adds i to food_production.
func (m *CityMutation) AddFoodProduction(i int) {
	if m.addfood_production != nil {
		*m.addfood_production += i
	} else {
		m.addfood_production = &i
	}
}

// AddedFoodProduction returns the value that was added to the food_production field in this mutation.
func (m *CityMutation) AddedFoodProduction() (r int, exists bool) {
	v := m.addfood_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodProduction reset all changes of the food_production field.
func (m *CityMutation) ResetFoodProduction() {
	m.food_production = nil
	m.addfood_production = nil
}

// SetWoodStored sets the wood_stored field.
func (m *CityMutation) SetWoodStored(i int) {
	m.wood_stored = &i
	m.addwood_stored = nil
}

// WoodStored returns the wood_stored value in the mutation.
func (m *CityMutation) WoodStored() (r int, exists bool) {
	v := m.wood_stored
	if v == nil {
		return
	}
	return *v, true
}

// AddWoodStored adds i to wood_stored.
func (m *CityMutation) AddWoodStored(i int) {
	if m.addwood_stored != nil {
		*m.addwood_stored += i
	} else {
		m.addwood_stored = &i
	}
}

// AddedWoodStored returns the value that was added to the wood_stored field in this mutation.
func (m *CityMutation) AddedWoodStored() (r int, exists bool) {
	v := m.addwood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodStored reset all changes of the wood_stored field.
func (m *CityMutation) ResetWoodStored() {
	m.wood_stored = nil
	m.addwood_stored = nil
}

// SetStoneStored sets the stone_stored field.
func (m *CityMutation) SetStoneStored(i int) {
	m.stone_stored = &i
	m.addstone_stored = nil
}

// StoneStored returns the stone_stored value in the mutation.
func (m *CityMutation) StoneStored() (r int, exists bool) {
	v := m.stone_stored
	if v == nil {
		return
	}
	return *v, true
}

// AddStoneStored adds i to stone_stored.
func (m *CityMutation) AddStoneStored(i int) {
	if m.addstone_stored != nil {
		*m.addstone_stored += i
	} else {
		m.addstone_stored = &i
	}
}

// AddedStoneStored returns the value that was added to the stone_stored field in this mutation.
func (m *CityMutation) AddedStoneStored() (r int, exists bool) {
	v := m.addstone_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneStored reset all changes of the stone_stored field.
func (m *CityMutation) ResetStoneStored() {
	m.stone_stored = nil
	m.addstone_stored = nil
}

// SetIronStored sets the iron_stored field.
func (m *CityMutation) SetIronStored(i int) {
	m.iron_stored = &i
	m.addiron_stored = nil
}

// IronStored returns the iron_stored value in the mutation.
func (m *CityMutation) IronStored() (r int, exists bool) {
	v := m.iron_stored
	if v == nil {
		return
	}
	return *v, true
}

// AddIronStored adds i to iron_stored.
func (m *CityMutation) AddIronStored(i int) {
	if m.addiron_stored != nil {
		*m.addiron_stored += i
	} else {
		m.addiron_stored = &i
	}
}

// AddedIronStored returns the value that was added to the iron_stored field in this mutation.
func (m *CityMutation) AddedIronStored() (r int, exists bool) {
	v := m.addiron_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronStored reset all changes of the iron_stored field.
func (m *CityMutation) ResetIronStored() {
	m.iron_stored = nil
	m.addiron_stored = nil
}

// SetFoodStored sets the food_stored field.
func (m *CityMutation) SetFoodStored(i int) {
	m.food_stored = &i
	m.addfood_stored = nil
}

// FoodStored returns the food_stored value in the mutation.
func (m *CityMutation) FoodStored() (r int, exists bool) {
	v := m.food_stored
	if v == nil {
		return
	}
	return *v, true
}

// AddFoodStored adds i to food_stored.
func (m *CityMutation) AddFoodStored(i int) {
	if m.addfood_stored != nil {
		*m.addfood_stored += i
	} else {
		m.addfood_stored = &i
	}
}

// AddedFoodStored returns the value that was added to the food_stored field in this mutation.
func (m *CityMutation) AddedFoodStored() (r int, exists bool) {
	v := m.addfood_stored
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodStored reset all changes of the food_stored field.
func (m *CityMutation) ResetFoodStored() {
	m.food_stored = nil
	m.addfood_stored = nil
}

// SetWoodLimit sets the wood_limit field.
func (m *CityMutation) SetWoodLimit(i int) {
	m.wood_limit = &i
	m.addwood_limit = nil
}

// WoodLimit returns the wood_limit value in the mutation.
func (m *CityMutation) WoodLimit() (r int, exists bool) {
	v := m.wood_limit
	if v == nil {
		return
	}
	return *v, true
}

// AddWoodLimit adds i to wood_limit.
func (m *CityMutation) AddWoodLimit(i int) {
	if m.addwood_limit != nil {
		*m.addwood_limit += i
	} else {
		m.addwood_limit = &i
	}
}

// AddedWoodLimit returns the value that was added to the wood_limit field in this mutation.
func (m *CityMutation) AddedWoodLimit() (r int, exists bool) {
	v := m.addwood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetWoodLimit reset all changes of the wood_limit field.
func (m *CityMutation) ResetWoodLimit() {
	m.wood_limit = nil
	m.addwood_limit = nil
}

// SetStoneLimit sets the stone_limit field.
func (m *CityMutation) SetStoneLimit(i int) {
	m.stone_limit = &i
	m.addstone_limit = nil
}

// StoneLimit returns the stone_limit value in the mutation.
func (m *CityMutation) StoneLimit() (r int, exists bool) {
	v := m.stone_limit
	if v == nil {
		return
	}
	return *v, true
}

// AddStoneLimit adds i to stone_limit.
func (m *CityMutation) AddStoneLimit(i int) {
	if m.addstone_limit != nil {
		*m.addstone_limit += i
	} else {
		m.addstone_limit = &i
	}
}

// AddedStoneLimit returns the value that was added to the stone_limit field in this mutation.
func (m *CityMutation) AddedStoneLimit() (r int, exists bool) {
	v := m.addstone_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoneLimit reset all changes of the stone_limit field.
func (m *CityMutation) ResetStoneLimit() {
	m.stone_limit = nil
	m.addstone_limit = nil
}

// SetIronLimit sets the iron_limit field.
func (m *CityMutation) SetIronLimit(i int) {
	m.iron_limit = &i
	m.addiron_limit = nil
}

// IronLimit returns the iron_limit value in the mutation.
func (m *CityMutation) IronLimit() (r int, exists bool) {
	v := m.iron_limit
	if v == nil {
		return
	}
	return *v, true
}

// AddIronLimit adds i to iron_limit.
func (m *CityMutation) AddIronLimit(i int) {
	if m.addiron_limit != nil {
		*m.addiron_limit += i
	} else {
		m.addiron_limit = &i
	}
}

// AddedIronLimit returns the value that was added to the iron_limit field in this mutation.
func (m *CityMutation) AddedIronLimit() (r int, exists bool) {
	v := m.addiron_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetIronLimit reset all changes of the iron_limit field.
func (m *CityMutation) ResetIronLimit() {
	m.iron_limit = nil
	m.addiron_limit = nil
}

// SetFoodLimit sets the food_limit field.
func (m *CityMutation) SetFoodLimit(i int) {
	m.food_limit = &i
	m.addfood_limit = nil
}

// FoodLimit returns the food_limit value in the mutation.
func (m *CityMutation) FoodLimit() (r int, exists bool) {
	v := m.food_limit
	if v == nil {
		return
	}
	return *v, true
}

// AddFoodLimit adds i to food_limit.
func (m *CityMutation) AddFoodLimit(i int) {
	if m.addfood_limit != nil {
		*m.addfood_limit += i
	} else {
		m.addfood_limit = &i
	}
}

// AddedFoodLimit returns the value that was added to the food_limit field in this mutation.
func (m *CityMutation) AddedFoodLimit() (r int, exists bool) {
	v := m.addfood_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetFoodLimit reset all changes of the food_limit field.
func (m *CityMutation) ResetFoodLimit() {
	m.food_limit = nil
	m.addfood_limit = nil
}

// SetQueueTime sets the queue_time field.
func (m *CityMutation) SetQueueTime(t time.Time) {
	m.queue_time = &t
}

// QueueTime returns the queue_time value in the mutation.
func (m *CityMutation) QueueTime() (r time.Time, exists bool) {
	v := m.queue_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetQueueTime reset all changes of the queue_time field.
func (m *CityMutation) ResetQueueTime() {
	m.queue_time = nil
}

// SetConstructionSpeed sets the construction_speed field.
func (m *CityMutation) SetConstructionSpeed(i int) {
	m.construction_speed = &i
	m.addconstruction_speed = nil
}

// ConstructionSpeed returns the construction_speed value in the mutation.
func (m *CityMutation) ConstructionSpeed() (r int, exists bool) {
	v := m.construction_speed
	if v == nil {
		return
	}
	return *v, true
}

// AddConstructionSpeed adds i to construction_speed.
func (m *CityMutation) AddConstructionSpeed(i int) {
	if m.addconstruction_speed != nil {
		*m.addconstruction_speed += i
	} else {
		m.addconstruction_speed = &i
	}
}

// AddedConstructionSpeed returns the value that was added to the construction_speed field in this mutation.
func (m *CityMutation) AddedConstructionSpeed() (r int, exists bool) {
	v := m.addconstruction_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetConstructionSpeed reset all changes of the construction_speed field.
func (m *CityMutation) ResetConstructionSpeed() {
	m.construction_speed = nil
	m.addconstruction_speed = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *CityMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *CityMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *CityMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *CityMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CityMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the owner edge.
func (m *CityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddConstructionIDs adds the constructions edge to Construction by ids.
func (m *CityMutation) AddConstructionIDs(ids ...int) {
	if m.constructions == nil {
		m.constructions = make(map[int]struct{})
	}
	for i := range ids {
		m.constructions[ids[i]] = struct{}{}
	}
}

// RemoveConstructionIDs removes the constructions edge to Construction by ids.
func (m *CityMutation) RemoveConstructionIDs(ids ...int) {
	if m.removedconstructions == nil {
		m.removedconstructions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedconstructions[ids[i]] = struct{}{}
	}
}

// RemovedConstructions returns the removed ids of constructions.
func (m *CityMutation) RemovedConstructionsIDs() (ids []int) {
	for id := range m.removedconstructions {
		ids = append(ids, id)
	}
	return
}

// ConstructionsIDs returns the constructions ids in the mutation.
func (m *CityMutation) ConstructionsIDs() (ids []int) {
	for id := range m.constructions {
		ids = append(ids, id)
	}
	return
}

// ResetConstructions reset all changes of the constructions edge.
func (m *CityMutation) ResetConstructions() {
	m.constructions = nil
	m.removedconstructions = nil
}

// AddQueueIDs adds the queue edge to Queue by ids.
func (m *CityMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to Queue by ids.
func (m *CityMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *CityMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *CityMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the queue edge.
func (m *CityMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.x != nil {
		fields = append(fields, city.FieldX)
	}
	if m.y != nil {
		fields = append(fields, city.FieldY)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.points != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.wood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.stone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.iron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.food_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.wood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.stone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.iron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.food_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.wood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.stone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.iron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.food_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.queue_time != nil {
		fields = append(fields, city.FieldQueueTime)
	}
	if m.construction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.X()
	case city.FieldY:
		return m.Y()
	case city.FieldName:
		return m.Name()
	case city.FieldPoints:
		return m.Points()
	case city.FieldWoodProduction:
		return m.WoodProduction()
	case city.FieldStoneProduction:
		return m.StoneProduction()
	case city.FieldIronProduction:
		return m.IronProduction()
	case city.FieldFoodProduction:
		return m.FoodProduction()
	case city.FieldWoodStored:
		return m.WoodStored()
	case city.FieldStoneStored:
		return m.StoneStored()
	case city.FieldIronStored:
		return m.IronStored()
	case city.FieldFoodStored:
		return m.FoodStored()
	case city.FieldWoodLimit:
		return m.WoodLimit()
	case city.FieldStoneLimit:
		return m.StoneLimit()
	case city.FieldIronLimit:
		return m.IronLimit()
	case city.FieldFoodLimit:
		return m.FoodLimit()
	case city.FieldQueueTime:
		return m.QueueTime()
	case city.FieldConstructionSpeed:
		return m.ConstructionSpeed()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFoodLimit(v)
		return nil
	case city.FieldQueueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueTime(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, city.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, city.FieldY)
	}
	if m.addpoints != nil {
		fields = append(fields, city.FieldPoints)
	}
	if m.addwood_production != nil {
		fields = append(fields, city.FieldWoodProduction)
	}
	if m.addstone_production != nil {
		fields = append(fields, city.FieldStoneProduction)
	}
	if m.addiron_production != nil {
		fields = append(fields, city.FieldIronProduction)
	}
	if m.addfood_production != nil {
		fields = append(fields, city.FieldFoodProduction)
	}
	if m.addwood_stored != nil {
		fields = append(fields, city.FieldWoodStored)
	}
	if m.addstone_stored != nil {
		fields = append(fields, city.FieldStoneStored)
	}
	if m.addiron_stored != nil {
		fields = append(fields, city.FieldIronStored)
	}
	if m.addfood_stored != nil {
		fields = append(fields, city.FieldFoodStored)
	}
	if m.addwood_limit != nil {
		fields = append(fields, city.FieldWoodLimit)
	}
	if m.addstone_limit != nil {
		fields = append(fields, city.FieldStoneLimit)
	}
	if m.addiron_limit != nil {
		fields = append(fields, city.FieldIronLimit)
	}
	if m.addfood_limit != nil {
		fields = append(fields, city.FieldFoodLimit)
	}
	if m.addconstruction_speed != nil {
		fields = append(fields, city.FieldConstructionSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldX:
		return m.AddedX()
	case city.FieldY:
		return m.AddedY()
	case city.FieldPoints:
		return m.AddedPoints()
	case city.FieldWoodProduction:
		return m.AddedWoodProduction()
	case city.FieldStoneProduction:
		return m.AddedStoneProduction()
	case city.FieldIronProduction:
		return m.AddedIronProduction()
	case city.FieldFoodProduction:
		return m.AddedFoodProduction()
	case city.FieldWoodStored:
		return m.AddedWoodStored()
	case city.FieldStoneStored:
		return m.AddedStoneStored()
	case city.FieldIronStored:
		return m.AddedIronStored()
	case city.FieldFoodStored:
		return m.AddedFoodStored()
	case city.FieldWoodLimit:
		return m.AddedWoodLimit()
	case city.FieldStoneLimit:
		return m.AddedStoneLimit()
	case city.FieldIronLimit:
		return m.AddedIronLimit()
	case city.FieldFoodLimit:
		return m.AddedFoodLimit()
	case city.FieldConstructionSpeed:
		return m.AddedConstructionSpeed()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case city.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case city.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case city.FieldWoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodProduction(v)
		return nil
	case city.FieldStoneProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneProduction(v)
		return nil
	case city.FieldIronProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronProduction(v)
		return nil
	case city.FieldFoodProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodProduction(v)
		return nil
	case city.FieldWoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodStored(v)
		return nil
	case city.FieldStoneStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneStored(v)
		return nil
	case city.FieldIronStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronStored(v)
		return nil
	case city.FieldFoodStored:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodStored(v)
		return nil
	case city.FieldWoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWoodLimit(v)
		return nil
	case city.FieldStoneLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoneLimit(v)
		return nil
	case city.FieldIronLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIronLimit(v)
		return nil
	case city.FieldFoodLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFoodLimit(v)
		return nil
	case city.FieldConstructionSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConstructionSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldX:
		m.ResetX()
		return nil
	case city.FieldY:
		m.ResetY()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldPoints:
		m.ResetPoints()
		return nil
	case city.FieldWoodProduction:
		m.ResetWoodProduction()
		return nil
	case city.FieldStoneProduction:
		m.ResetStoneProduction()
		return nil
	case city.FieldIronProduction:
		m.ResetIronProduction()
		return nil
	case city.FieldFoodProduction:
		m.ResetFoodProduction()
		return nil
	case city.FieldWoodStored:
		m.ResetWoodStored()
		return nil
	case city.FieldStoneStored:
		m.ResetStoneStored()
		return nil
	case city.FieldIronStored:
		m.ResetIronStored()
		return nil
	case city.FieldFoodStored:
		m.ResetFoodStored()
		return nil
	case city.FieldWoodLimit:
		m.ResetWoodLimit()
		return nil
	case city.FieldStoneLimit:
		m.ResetStoneLimit()
		return nil
	case city.FieldIronLimit:
		m.ResetIronLimit()
		return nil
	case city.FieldFoodLimit:
		m.ResetFoodLimit()
		return nil
	case city.FieldQueueTime:
		m.ResetQueueTime()
		return nil
	case city.FieldConstructionSpeed:
		m.ResetConstructionSpeed()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, city.EdgeOwner)
	}
	if m.constructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.queue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.constructions))
		for id := range m.constructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedconstructions != nil {
		edges = append(edges, city.EdgeConstructions)
	}
	if m.removedqueue != nil {
		edges = append(edges, city.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeConstructions:
		ids := make([]ent.Value, 0, len(m.removedconstructions))
		for id := range m.removedconstructions {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, city.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeOwner:
		m.ResetOwner()
		return nil
	case city.EdgeConstructions:
		m.ResetConstructions()
		return nil
	case city.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// ConstructionMutation represents an operation that mutate the Constructions
// nodes in the graph.
type ConstructionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	x                 *int
	addx              *int
	y                 *int
	addy              *int
	raw_production    *int
	addraw_production *int
	_type             *int
	add_type          *int
	level             *int
	addlevel          *int
	modifier          *float64
	addmodifier       *float64
	need_refresh      *bool
	clearedFields     map[string]struct{}
	city              *int
	clearedcity       bool
	queue             map[int]struct{}
	removedqueue      map[int]struct{}
}

var _ ent.Mutation = (*ConstructionMutation)(nil)

// newConstructionMutation creates new mutation for $n.Name.
func newConstructionMutation(c config, op Op) *ConstructionMutation {
	return &ConstructionMutation{
		config:        c,
		op:            op,
		typ:           TypeConstruction,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConstructionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConstructionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConstructionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the x field.
func (m *ConstructionMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the x value in the mutation.
func (m *ConstructionMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// AddX adds i to x.
func (m *ConstructionMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the x field in this mutation.
func (m *ConstructionMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX reset all changes of the x field.
func (m *ConstructionMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the y field.
func (m *ConstructionMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the y value in the mutation.
func (m *ConstructionMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// AddY adds i to y.
func (m *ConstructionMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the y field in this mutation.
func (m *ConstructionMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY reset all changes of the y field.
func (m *ConstructionMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetRawProduction sets the raw_production field.
func (m *ConstructionMutation) SetRawProduction(i int) {
	m.raw_production = &i
	m.addraw_production = nil
}

// RawProduction returns the raw_production value in the mutation.
func (m *ConstructionMutation) RawProduction() (r int, exists bool) {
	v := m.raw_production
	if v == nil {
		return
	}
	return *v, true
}

// AddRawProduction adds i to raw_production.
func (m *ConstructionMutation) AddRawProduction(i int) {
	if m.addraw_production != nil {
		*m.addraw_production += i
	} else {
		m.addraw_production = &i
	}
}

// AddedRawProduction returns the value that was added to the raw_production field in this mutation.
func (m *ConstructionMutation) AddedRawProduction() (r int, exists bool) {
	v := m.addraw_production
	if v == nil {
		return
	}
	return *v, true
}

// ResetRawProduction reset all changes of the raw_production field.
func (m *ConstructionMutation) ResetRawProduction() {
	m.raw_production = nil
	m.addraw_production = nil
}

// SetType sets the type field.
func (m *ConstructionMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *ConstructionMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// AddType adds i to type.
func (m *ConstructionMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *ConstructionMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the type field.
func (m *ConstructionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLevel sets the level field.
func (m *ConstructionMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the level value in the mutation.
func (m *ConstructionMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// AddLevel adds i to level.
func (m *ConstructionMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the level field in this mutation.
func (m *ConstructionMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel reset all changes of the level field.
func (m *ConstructionMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetModifier sets the modifier field.
func (m *ConstructionMutation) SetModifier(f float64) {
	m.modifier = &f
	m.addmodifier = nil
}

// Modifier returns the modifier value in the mutation.
func (m *ConstructionMutation) Modifier() (r float64, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// AddModifier adds f to modifier.
func (m *ConstructionMutation) AddModifier(f float64) {
	if m.addmodifier != nil {
		*m.addmodifier += f
	} else {
		m.addmodifier = &f
	}
}

// AddedModifier returns the value that was added to the modifier field in this mutation.
func (m *ConstructionMutation) AddedModifier() (r float64, exists bool) {
	v := m.addmodifier
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifier reset all changes of the modifier field.
func (m *ConstructionMutation) ResetModifier() {
	m.modifier = nil
	m.addmodifier = nil
}

// SetNeedRefresh sets the need_refresh field.
func (m *ConstructionMutation) SetNeedRefresh(b bool) {
	m.need_refresh = &b
}

// NeedRefresh returns the need_refresh value in the mutation.
func (m *ConstructionMutation) NeedRefresh() (r bool, exists bool) {
	v := m.need_refresh
	if v == nil {
		return
	}
	return *v, true
}

// ResetNeedRefresh reset all changes of the need_refresh field.
func (m *ConstructionMutation) ResetNeedRefresh() {
	m.need_refresh = nil
}

// SetCityID sets the city edge to City by id.
func (m *ConstructionMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the city edge to City.
func (m *ConstructionMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared returns if the edge city was cleared.
func (m *ConstructionMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the city id in the mutation.
func (m *ConstructionMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the city ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ConstructionMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity reset all changes of the city edge.
func (m *ConstructionMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddQueueIDs adds the queue edge to Queue by ids.
func (m *ConstructionMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to Queue by ids.
func (m *ConstructionMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *ConstructionMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *ConstructionMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the queue edge.
func (m *ConstructionMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *ConstructionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Construction).
func (m *ConstructionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConstructionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.x != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.y != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.raw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m._type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.level != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.modifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	if m.need_refresh != nil {
		fields = append(fields, construction.FieldNeedRefresh)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConstructionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.X()
	case construction.FieldY:
		return m.Y()
	case construction.FieldRawProduction:
		return m.RawProduction()
	case construction.FieldType:
		return m.GetType()
	case construction.FieldLevel:
		return m.Level()
	case construction.FieldModifier:
		return m.Modifier()
	case construction.FieldNeedRefresh:
		return m.NeedRefresh()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConstructionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case construction.FieldNeedRefresh:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedRefresh(v)
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConstructionMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, construction.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, construction.FieldY)
	}
	if m.addraw_production != nil {
		fields = append(fields, construction.FieldRawProduction)
	}
	if m.add_type != nil {
		fields = append(fields, construction.FieldType)
	}
	if m.addlevel != nil {
		fields = append(fields, construction.FieldLevel)
	}
	if m.addmodifier != nil {
		fields = append(fields, construction.FieldModifier)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConstructionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case construction.FieldX:
		return m.AddedX()
	case construction.FieldY:
		return m.AddedY()
	case construction.FieldRawProduction:
		return m.AddedRawProduction()
	case construction.FieldType:
		return m.AddedType()
	case construction.FieldLevel:
		return m.AddedLevel()
	case construction.FieldModifier:
		return m.AddedModifier()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConstructionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case construction.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case construction.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case construction.FieldRawProduction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRawProduction(v)
		return nil
	case construction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case construction.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case construction.FieldModifier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifier(v)
		return nil
	}
	return fmt.Errorf("unknown Construction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConstructionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConstructionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConstructionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Construction nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConstructionMutation) ResetField(name string) error {
	switch name {
	case construction.FieldX:
		m.ResetX()
		return nil
	case construction.FieldY:
		m.ResetY()
		return nil
	case construction.FieldRawProduction:
		m.ResetRawProduction()
		return nil
	case construction.FieldType:
		m.ResetType()
		return nil
	case construction.FieldLevel:
		m.ResetLevel()
		return nil
	case construction.FieldModifier:
		m.ResetModifier()
		return nil
	case construction.FieldNeedRefresh:
		m.ResetNeedRefresh()
		return nil
	}
	return fmt.Errorf("unknown Construction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConstructionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.city != nil {
		edges = append(edges, construction.EdgeCity)
	}
	if m.queue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConstructionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConstructionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedqueue != nil {
		edges = append(edges, construction.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConstructionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case construction.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConstructionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcity {
		edges = append(edges, construction.EdgeCity)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConstructionMutation) EdgeCleared(name string) bool {
	switch name {
	case construction.EdgeCity:
		return m.clearedcity
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConstructionMutation) ClearEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Construction unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConstructionMutation) ResetEdge(name string) error {
	switch name {
	case construction.EdgeCity:
		m.ResetCity()
		return nil
	case construction.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown Construction edge %s", name)
}

// QueueMutation represents an operation that mutate the Queues
// nodes in the graph.
type QueueMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Completion         *time.Time
	_Action             *int
	add_Action          *int
	clearedFields       map[string]struct{}
	city                *int
	clearedcity         bool
	construction        *int
	clearedconstruction bool
}

var _ ent.Mutation = (*QueueMutation)(nil)

// newQueueMutation creates new mutation for $n.Name.
func newQueueMutation(c config, op Op) *QueueMutation {
	return &QueueMutation{
		config:        c,
		op:            op,
		typ:           TypeQueue,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *QueueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCompletion sets the Completion field.
func (m *QueueMutation) SetCompletion(t time.Time) {
	m._Completion = &t
}

// Completion returns the Completion value in the mutation.
func (m *QueueMutation) Completion() (r time.Time, exists bool) {
	v := m._Completion
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletion reset all changes of the Completion field.
func (m *QueueMutation) ResetCompletion() {
	m._Completion = nil
}

// SetAction sets the Action field.
func (m *QueueMutation) SetAction(i int) {
	m._Action = &i
	m.add_Action = nil
}

// Action returns the Action value in the mutation.
func (m *QueueMutation) Action() (r int, exists bool) {
	v := m._Action
	if v == nil {
		return
	}
	return *v, true
}

// AddAction adds i to Action.
func (m *QueueMutation) AddAction(i int) {
	if m.add_Action != nil {
		*m.add_Action += i
	} else {
		m.add_Action = &i
	}
}

// AddedAction returns the value that was added to the Action field in this mutation.
func (m *QueueMutation) AddedAction() (r int, exists bool) {
	v := m.add_Action
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction reset all changes of the Action field.
func (m *QueueMutation) ResetAction() {
	m._Action = nil
	m.add_Action = nil
}

// SetCityID sets the city edge to City by id.
func (m *QueueMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the city edge to City.
func (m *QueueMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared returns if the edge city was cleared.
func (m *QueueMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the city id in the mutation.
func (m *QueueMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the city ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity reset all changes of the city edge.
func (m *QueueMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetConstructionID sets the construction edge to Construction by id.
func (m *QueueMutation) SetConstructionID(id int) {
	m.construction = &id
}

// ClearConstruction clears the construction edge to Construction.
func (m *QueueMutation) ClearConstruction() {
	m.clearedconstruction = true
}

// ConstructionCleared returns if the edge construction was cleared.
func (m *QueueMutation) ConstructionCleared() bool {
	return m.clearedconstruction
}

// ConstructionID returns the construction id in the mutation.
func (m *QueueMutation) ConstructionID() (id int, exists bool) {
	if m.construction != nil {
		return *m.construction, true
	}
	return
}

// ConstructionIDs returns the construction ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConstructionID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) ConstructionIDs() (ids []int) {
	if id := m.construction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConstruction reset all changes of the construction edge.
func (m *QueueMutation) ResetConstruction() {
	m.construction = nil
	m.clearedconstruction = false
}

// Op returns the operation name.
func (m *QueueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Queue).
func (m *QueueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *QueueMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Completion != nil {
		fields = append(fields, queue.FieldCompletion)
	}
	if m._Action != nil {
		fields = append(fields, queue.FieldAction)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *QueueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldCompletion:
		return m.Completion()
	case queue.FieldAction:
		return m.Action()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queue.FieldCompletion:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletion(v)
		return nil
	case queue.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *QueueMutation) AddedFields() []string {
	var fields []string
	if m.add_Action != nil {
		fields = append(fields, queue.FieldAction)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *QueueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldAction:
		return m.AddedAction()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case queue.FieldAction:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	}
	return fmt.Errorf("unknown Queue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *QueueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *QueueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Queue nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *QueueMutation) ResetField(name string) error {
	switch name {
	case queue.FieldCompletion:
		m.ResetCompletion()
		return nil
	case queue.FieldAction:
		m.ResetAction()
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *QueueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.city != nil {
		edges = append(edges, queue.EdgeCity)
	}
	if m.construction != nil {
		edges = append(edges, queue.EdgeConstruction)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *QueueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case queue.EdgeConstruction:
		if id := m.construction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *QueueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *QueueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *QueueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcity {
		edges = append(edges, queue.EdgeCity)
	}
	if m.clearedconstruction {
		edges = append(edges, queue.EdgeConstruction)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *QueueMutation) EdgeCleared(name string) bool {
	switch name {
	case queue.EdgeCity:
		return m.clearedcity
	case queue.EdgeConstruction:
		return m.clearedconstruction
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *QueueMutation) ClearEdge(name string) error {
	switch name {
	case queue.EdgeCity:
		m.ClearCity()
		return nil
	case queue.EdgeConstruction:
		m.ClearConstruction()
		return nil
	}
	return fmt.Errorf("unknown Queue unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *QueueMutation) ResetEdge(name string) error {
	switch name {
	case queue.EdgeCity:
		m.ResetCity()
		return nil
	case queue.EdgeConstruction:
		m.ResetConstruction()
		return nil
	}
	return fmt.Errorf("unknown Queue edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	email            *string
	password_hash    *string
	gold             *int
	addgold          *int
	diamonds         *int
	adddiamonds      *int
	darkwood         *int
	adddarkwood      *int
	runestone        *int
	addrunestone     *int
	veritium         *int
	addveritium      *int
	trueseed         *int
	addtrueseed      *int
	rank             *int
	addrank          *int
	alliance_rank    *int
	addalliance_rank *int
	clearedFields    map[string]struct{}
	cities           map[int]struct{}
	removedcities    map[int]struct{}
}

var _ ent.Mutation = (*UserMutation)(nil)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op) *UserMutation {
	return &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmail reset all changes of the email field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the password_hash field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the password_hash value in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// ResetPasswordHash reset all changes of the password_hash field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetGold sets the gold field.
func (m *UserMutation) SetGold(i int) {
	m.gold = &i
	m.addgold = nil
}

// Gold returns the gold value in the mutation.
func (m *UserMutation) Gold() (r int, exists bool) {
	v := m.gold
	if v == nil {
		return
	}
	return *v, true
}

// AddGold adds i to gold.
func (m *UserMutation) AddGold(i int) {
	if m.addgold != nil {
		*m.addgold += i
	} else {
		m.addgold = &i
	}
}

// AddedGold returns the value that was added to the gold field in this mutation.
func (m *UserMutation) AddedGold() (r int, exists bool) {
	v := m.addgold
	if v == nil {
		return
	}
	return *v, true
}

// ResetGold reset all changes of the gold field.
func (m *UserMutation) ResetGold() {
	m.gold = nil
	m.addgold = nil
}

// SetDiamonds sets the diamonds field.
func (m *UserMutation) SetDiamonds(i int) {
	m.diamonds = &i
	m.adddiamonds = nil
}

// Diamonds returns the diamonds value in the mutation.
func (m *UserMutation) Diamonds() (r int, exists bool) {
	v := m.diamonds
	if v == nil {
		return
	}
	return *v, true
}

// AddDiamonds adds i to diamonds.
func (m *UserMutation) AddDiamonds(i int) {
	if m.adddiamonds != nil {
		*m.adddiamonds += i
	} else {
		m.adddiamonds = &i
	}
}

// AddedDiamonds returns the value that was added to the diamonds field in this mutation.
func (m *UserMutation) AddedDiamonds() (r int, exists bool) {
	v := m.adddiamonds
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiamonds reset all changes of the diamonds field.
func (m *UserMutation) ResetDiamonds() {
	m.diamonds = nil
	m.adddiamonds = nil
}

// SetDarkwood sets the darkwood field.
func (m *UserMutation) SetDarkwood(i int) {
	m.darkwood = &i
	m.adddarkwood = nil
}

// Darkwood returns the darkwood value in the mutation.
func (m *UserMutation) Darkwood() (r int, exists bool) {
	v := m.darkwood
	if v == nil {
		return
	}
	return *v, true
}

// AddDarkwood adds i to darkwood.
func (m *UserMutation) AddDarkwood(i int) {
	if m.adddarkwood != nil {
		*m.adddarkwood += i
	} else {
		m.adddarkwood = &i
	}
}

// AddedDarkwood returns the value that was added to the darkwood field in this mutation.
func (m *UserMutation) AddedDarkwood() (r int, exists bool) {
	v := m.adddarkwood
	if v == nil {
		return
	}
	return *v, true
}

// ResetDarkwood reset all changes of the darkwood field.
func (m *UserMutation) ResetDarkwood() {
	m.darkwood = nil
	m.adddarkwood = nil
}

// SetRunestone sets the runestone field.
func (m *UserMutation) SetRunestone(i int) {
	m.runestone = &i
	m.addrunestone = nil
}

// Runestone returns the runestone value in the mutation.
func (m *UserMutation) Runestone() (r int, exists bool) {
	v := m.runestone
	if v == nil {
		return
	}
	return *v, true
}

// AddRunestone adds i to runestone.
func (m *UserMutation) AddRunestone(i int) {
	if m.addrunestone != nil {
		*m.addrunestone += i
	} else {
		m.addrunestone = &i
	}
}

// AddedRunestone returns the value that was added to the runestone field in this mutation.
func (m *UserMutation) AddedRunestone() (r int, exists bool) {
	v := m.addrunestone
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunestone reset all changes of the runestone field.
func (m *UserMutation) ResetRunestone() {
	m.runestone = nil
	m.addrunestone = nil
}

// SetVeritium sets the veritium field.
func (m *UserMutation) SetVeritium(i int) {
	m.veritium = &i
	m.addveritium = nil
}

// Veritium returns the veritium value in the mutation.
func (m *UserMutation) Veritium() (r int, exists bool) {
	v := m.veritium
	if v == nil {
		return
	}
	return *v, true
}

// AddVeritium adds i to veritium.
func (m *UserMutation) AddVeritium(i int) {
	if m.addveritium != nil {
		*m.addveritium += i
	} else {
		m.addveritium = &i
	}
}

// AddedVeritium returns the value that was added to the veritium field in this mutation.
func (m *UserMutation) AddedVeritium() (r int, exists bool) {
	v := m.addveritium
	if v == nil {
		return
	}
	return *v, true
}

// ResetVeritium reset all changes of the veritium field.
func (m *UserMutation) ResetVeritium() {
	m.veritium = nil
	m.addveritium = nil
}

// SetTrueseed sets the trueseed field.
func (m *UserMutation) SetTrueseed(i int) {
	m.trueseed = &i
	m.addtrueseed = nil
}

// Trueseed returns the trueseed value in the mutation.
func (m *UserMutation) Trueseed() (r int, exists bool) {
	v := m.trueseed
	if v == nil {
		return
	}
	return *v, true
}

// AddTrueseed adds i to trueseed.
func (m *UserMutation) AddTrueseed(i int) {
	if m.addtrueseed != nil {
		*m.addtrueseed += i
	} else {
		m.addtrueseed = &i
	}
}

// AddedTrueseed returns the value that was added to the trueseed field in this mutation.
func (m *UserMutation) AddedTrueseed() (r int, exists bool) {
	v := m.addtrueseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrueseed reset all changes of the trueseed field.
func (m *UserMutation) ResetTrueseed() {
	m.trueseed = nil
	m.addtrueseed = nil
}

// SetRank sets the rank field.
func (m *UserMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the rank value in the mutation.
func (m *UserMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// AddRank adds i to rank.
func (m *UserMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the rank field in this mutation.
func (m *UserMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank reset all changes of the rank field.
func (m *UserMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetAllianceRank sets the alliance_rank field.
func (m *UserMutation) SetAllianceRank(i int) {
	m.alliance_rank = &i
	m.addalliance_rank = nil
}

// AllianceRank returns the alliance_rank value in the mutation.
func (m *UserMutation) AllianceRank() (r int, exists bool) {
	v := m.alliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// AddAllianceRank adds i to alliance_rank.
func (m *UserMutation) AddAllianceRank(i int) {
	if m.addalliance_rank != nil {
		*m.addalliance_rank += i
	} else {
		m.addalliance_rank = &i
	}
}

// AddedAllianceRank returns the value that was added to the alliance_rank field in this mutation.
func (m *UserMutation) AddedAllianceRank() (r int, exists bool) {
	v := m.addalliance_rank
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllianceRank reset all changes of the alliance_rank field.
func (m *UserMutation) ResetAllianceRank() {
	m.alliance_rank = nil
	m.addalliance_rank = nil
}

// AddCityIDs adds the cities edge to City by ids.
func (m *UserMutation) AddCityIDs(ids ...int) {
	if m.cities == nil {
		m.cities = make(map[int]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// RemoveCityIDs removes the cities edge to City by ids.
func (m *UserMutation) RemoveCityIDs(ids ...int) {
	if m.removedcities == nil {
		m.removedcities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed ids of cities.
func (m *UserMutation) RemovedCitiesIDs() (ids []int) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the cities ids in the mutation.
func (m *UserMutation) CitiesIDs() (ids []int) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities reset all changes of the cities edge.
func (m *UserMutation) ResetCities() {
	m.cities = nil
	m.removedcities = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.gold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.diamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.darkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.runestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.veritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.trueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.rank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.alliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldGold:
		return m.Gold()
	case user.FieldDiamonds:
		return m.Diamonds()
	case user.FieldDarkwood:
		return m.Darkwood()
	case user.FieldRunestone:
		return m.Runestone()
	case user.FieldVeritium:
		return m.Veritium()
	case user.FieldTrueseed:
		return m.Trueseed()
	case user.FieldRank:
		return m.Rank()
	case user.FieldAllianceRank:
		return m.AllianceRank()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addgold != nil {
		fields = append(fields, user.FieldGold)
	}
	if m.adddiamonds != nil {
		fields = append(fields, user.FieldDiamonds)
	}
	if m.adddarkwood != nil {
		fields = append(fields, user.FieldDarkwood)
	}
	if m.addrunestone != nil {
		fields = append(fields, user.FieldRunestone)
	}
	if m.addveritium != nil {
		fields = append(fields, user.FieldVeritium)
	}
	if m.addtrueseed != nil {
		fields = append(fields, user.FieldTrueseed)
	}
	if m.addrank != nil {
		fields = append(fields, user.FieldRank)
	}
	if m.addalliance_rank != nil {
		fields = append(fields, user.FieldAllianceRank)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGold:
		return m.AddedGold()
	case user.FieldDiamonds:
		return m.AddedDiamonds()
	case user.FieldDarkwood:
		return m.AddedDarkwood()
	case user.FieldRunestone:
		return m.AddedRunestone()
	case user.FieldVeritium:
		return m.AddedVeritium()
	case user.FieldTrueseed:
		return m.AddedTrueseed()
	case user.FieldRank:
		return m.AddedRank()
	case user.FieldAllianceRank:
		return m.AddedAllianceRank()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldGold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGold(v)
		return nil
	case user.FieldDiamonds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiamonds(v)
		return nil
	case user.FieldDarkwood:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDarkwood(v)
		return nil
	case user.FieldRunestone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunestone(v)
		return nil
	case user.FieldVeritium:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVeritium(v)
		return nil
	case user.FieldTrueseed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrueseed(v)
		return nil
	case user.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case user.FieldAllianceRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllianceRank(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldGold:
		m.ResetGold()
		return nil
	case user.FieldDiamonds:
		m.ResetDiamonds()
		return nil
	case user.FieldDarkwood:
		m.ResetDarkwood()
		return nil
	case user.FieldRunestone:
		m.ResetRunestone()
		return nil
	case user.FieldVeritium:
		m.ResetVeritium()
		return nil
	case user.FieldTrueseed:
		m.ResetTrueseed()
		return nil
	case user.FieldRank:
		m.ResetRank()
		return nil
	case user.FieldAllianceRank:
		m.ResetAllianceRank()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cities != nil {
		edges = append(edges, user.EdgeCities)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcities != nil {
		edges = append(edges, user.EdgeCities)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCities:
		m.ResetCities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
